08-05-2025
Watched this video https://www.youtube.com/watch?v=a0CVCcb0RJM
to get the basic overview of what has to be done. Then I found the original blog/video by Roy van Rijn from which the previous creator took the inspiration:
https://www.youtube.com/watch?v=T4PJoAh4X1g
16-05-2025
Quickly made the download function from youtube so I could use it to get a song to make a spectrogram. I have then attempted to verify it with comparison to the spectrogram from this website https://convert.ing-now.com/audio-spectrogram-creator/ and some inbuilt libraries. After taking a closer look at the detailed video by Roy van Rijn he mentioned checking it with song Equation by Aphex Twins which has an image of a face in a spectrogram. It sounded interesting so I decided to check that as well. 
After that I wrote the fingerprinting algorithm, added a standardized way to download the songs and store it in the database with its fingerprints.
17-05-2025
Made some general improvements to the code base. Found the RollingStone Top 500 Songs in json format from 
https://gist.githubusercontent.com/keune/0de5c7fb669f7b682874/raw/4aabd7282ee6b58ff886af50489cbcc6c4bd1faf/RollingStone%2520Top%2520500%2520Song
and implemented multiprocessing to download all the songs mentioned in the json file.
I have then implemented the matching algorithm but ran into an issue where it only worked for pieces of the original file and not for the recordings of music.
18-05-2025
I spent the day playing around with different window sizes and limited the frequency range to maximum of 6000Hz (within human ear range) without relying on Nyquist frequency. There was quite some success with this but it's still far from perfect. I have then implemented some error correction where one channel can have a wrong subchannel selected in a hash. This does not seem to have had much effect.
20-05-2025
I made a quick website that takes audio input, sends it to the server side via a websocket and then processes it live to try to find a song. I spent a lot of time here trying to decode the audio with ffmpeg and dealing with all the different codecs and versions. I have then found a wrapper of ffmpeg PyAV which made the job a lot easier. The algorithm does not work that well for the recorded audio so I spent the rest of the day trying to improve it. I also took a closer look at the repository of the video I watched at first and found this detailed description https://drive.google.com/file/d/1ahyCTXBAZiuni6RTzHzLoOwwfTRFaU-C/view
This describes a bit more complex algorithm with target zones and creating hashes that are connected to multiple points. To switch to this approach it would require a couple more days of work to properly implement and test. I tried to implement a slightly dumber version of this algorithm but it did not work well. I have then also attempted to switch the matching metric searching for a minimal standard deviation. I would say the main advantage of the algorithm described in the file is that it includes the time differences in the hash which makes it more resistant to noise. 
21-05-2025
Throughout the day I organized the code and made some general improvements to parts of it I did not like.


